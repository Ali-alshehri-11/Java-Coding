package DropboxPrep;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class _0924MinimizeMalwareSpread {

	public static void main(String[] args) {
		System.out.println(
				minMalwareSpread(new int[][] { new int[] { 1, 1, 0 }, new int[] { 1, 1, 0 }, new int[] { 0, 0, 1 } },
						new int[] { 0, 1 }));

		System.out.println(
				minMalwareSpread(new int[][] { new int[] { 1, 0, 0 }, new int[] { 0, 1, 0 }, new int[] { 0, 0, 1 } },
						new int[] { 0, 2 }));

		System.out.println(
				minMalwareSpread(new int[][] { new int[] { 1, 1, 1 }, new int[] { 1, 1, 1 }, new int[] { 1, 1, 1 } },
						new int[] { 1, 2 }));

		System.out.println(
				minMalwareSpread(new int[][] { new int[] { 1, 1, 0 }, new int[] { 1, 1, 1 }, new int[] { 0, 1, 1 } },
						new int[] { 0, 1 }));
	}

	static class Pair {
		int nodeId, reach;

		public Pair(int nodeId, int reach) {
			this.nodeId = nodeId;
			this.reach = reach;
		}

	}

	public static int minMalwareSpread(int[][] graph, int[] initial) {
		HashMap<Integer, List<Integer>> adjList = new HashMap<Integer, List<Integer>>();

		for (int i = 0; i < graph.length; i++) {
			for (int j = 0; j < graph[0].length; j++) {
				if (i != j && graph[i][j] == 1) {
					if (adjList.containsKey(i)) {
						adjList.get(i).add(j);
					} else {
						List<Integer> list = new ArrayList<Integer>();
						list.add(j);
						adjList.put(i, list);
					}
				}
			}
		}

		List<Pair> list = new ArrayList<Pair>();
		for (int i = 0; i < initial.length; i++) {
			list.add(new Pair(initial[i], bfs(initial[i], adjList)));
		}

		Collections.sort(list, new Comparator<Pair>() {

			@Override
			public int compare(Pair o1, Pair o2) {
				int val = o2.reach - o1.reach;
				if (val == 0)
					return o1.nodeId - o2.nodeId;
				return val;
			}
		});

		return list.get(0).nodeId;
	}

	public static int bfs(int source, HashMap<Integer, List<Integer>> adjList) {
		HashSet<Integer> visited = new HashSet<Integer>();
		int count = 0;
		Queue<Integer> q = new LinkedList<Integer>();
		q.offer(source);
		while (!q.isEmpty()) {
			int size = q.size();
			for (int i = 0; i < size; i++) {
				Integer src = q.poll();
				visited.add(src);
				if (adjList.containsKey(src)) {
					List<Integer> lst = adjList.get(src);
					for (int j = 0; j < lst.size(); j++) {
						Integer newSrc = lst.get(j);
						if (!visited.contains(newSrc)) {
							visited.add(newSrc);
							q.offer(newSrc);
						}
					}
				}
			}
			count++;
		}
		return count;
	}

}
